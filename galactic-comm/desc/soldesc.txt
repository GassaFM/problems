Можно было бы просто удвоить каждый бит.
Это недостаточно эффективно: из 30 битов получится 60,
а мы должны уложиться в 50 битов.

Решение 1: точное (требуется 43 бита).
Можно закодировать сообщение строкой Фибоначчи и передать её.
Рассмотрим сообщение как число в двоичной записи
и найдём строку Фибоначчи с таким номером.
Кодирование: если видим единицу, на следующей позиции окажется ноль.
Раскодирование: если видим единицу, просто пропускаем следующую цифру.
Очевидно, лучше нельзя: биты после единичек испорчены.

Решение 2: два случая (требуется 47 битов).
Посмотрим, сколько среди заданных 30 битов единиц.
Если 15 или меньше, кодируем так: 0 превращается в 0, а 1 в 10.
Если 16 или больше, кодируем наоборот: 1 превращается в 0, а 0 в 10.
В обоих случаях в конце дописываем что угодно: сам код занимает
от 30 до 45 битов.
Чтобы различить эти два случая, первым битом закодированного сообщения
запишем номер случая.
И ещё один ноль после него на случай, если он окажется единицей.
Раскодирование: вначале по первым двум битам узнаём,
надо ли инвертировать ответ.
Далее, пока не наберётся 30 битов, 0 превращается в 0,
а 1 превращается в 1 и пропускает следующую цифру кода.
После этого инвертируем ответ, если требуется.

Решение 3: разбиение на кусочки (требуется 50 битов).
Например, 10 кусочков по 3 бита превращаются в 10 кусочков по 5 битов:
000 -> 00000
001 -> 00010
010 -> 00100
011 -> 01000
100 -> 01010
101 -> 10000
110 -> 10010
111 -> 10100
Последний бит кода должен быть нулём, чтобы не портить следующий кусочек.
