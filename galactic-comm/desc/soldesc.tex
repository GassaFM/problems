Можно было бы просто удвоить каждый бит.
Это недостаточно эффективно: из 30 битов получится 60,
а мы должны уложиться в 50 битов.

\medskip
\textbf{Решение 1:} точное (требуется 43 бита).

Можно закодировать сообщение строкой Фибоначчи и передать её.
Строка Фибоначчи "--- это строка из нулей и единиц,
в которой нет двух единиц подряд.
В качестве подзадач используются две стандартные задачи:
\begin{shortnums}
\item Дана длина строки Фибоначчи $n$ и её номер $k$ среди всех строк
Фибоначчи длины $n$, найдите саму строку.
\item Дана строка Фибоначчи, найдите её лексикографический номер $k$
среди всех строк Фибоначчи такой же длины.
\end{shortnums}

Рассмотрим сообщение как число в двоичной записи
и найдём строку Фибоначчи длины 50 с таким номером.

Кодирование: если видим единицу, на следующей позиции окажется ноль.

Раскодирование: если видим единицу, просто пропускаем следующую цифру.

Из этого решения следует, что обойтись меньшим количеством битов,
чем 43, не получится, поскольку количество строк Фибоначчи из 42 битов
равно $701\,408\,733 < 2^{30}$.

\medskip
\textbf{Решение 2:} два случая (требуется 47 битов).

Посмотрим, сколько среди заданных 30 битов единиц.
Если 15 или меньше, кодируем так: \texttt{0} превращается в \texttt{0},
а \texttt{1} \texttt{10}.
Если 16 или больше, кодируем наоборот: \texttt{1} превращается в \texttt{0},
а \texttt{0} в \texttt{10}.
В обоих случаях в конце дописываем что угодно: сам код занимает
от 30 до 45 битов.
Чтобы различить эти два случая, первым битом закодированного сообщения
запишем номер случая.
И ещё один ноль после него на случай, если этот бит окажется единицей.

Раскодирование: вначале по первым двум битам узнаём,
надо ли инвертировать ответ.
Далее, пока не наберётся 30 битов, \texttt{0} превращается в \texttt{0},
а \texttt{1} превращается в \texttt{1} и пропускает следующую цифру кода.
После этого инвертируем ответ, если требуется.

\medskip
\textbf{Решение 3:} разбиение на кусочки (требуется 50 битов).

Например, разобьём сообщение на 10 кусочков по 3 бита,
а пакет на 10 кусочков по 5 битов.
Кусочки кодируем по отдельности.
Последний бит кода должен быть нулём, чтобы не портить следующий кусочек.
Каждый кусочек кодируем и затем раскодируем так:

\begin{center}
\begin{minipage}{0.16\thelinewidth}
$\texttt{000} \rightarrow \texttt{00000}$ \\
$\texttt{001} \rightarrow \texttt{00010}$ \\
$\texttt{010} \rightarrow \texttt{00100}$ \\
$\texttt{011} \rightarrow \texttt{01000}$ \\
$\texttt{100} \rightarrow \texttt{01010}$ \\
$\texttt{101} \rightarrow \texttt{10000}$ \\
$\texttt{110} \rightarrow \texttt{10010}$ \\
$\texttt{111} \rightarrow \texttt{10100}$ \\
\end{minipage}
~
\begin{minipage}{0.16\thelinewidth}
$\texttt{00000} \rightarrow \texttt{000}$ \\
$\texttt{0001?} \rightarrow \texttt{001}$ \\
$\texttt{001?0} \rightarrow \texttt{010}$ \\
$\texttt{01?00} \rightarrow \texttt{011}$ \\
$\texttt{01?1?} \rightarrow \texttt{100}$ \\
$\texttt{1?000} \rightarrow \texttt{101}$ \\
$\texttt{1?01?} \rightarrow \texttt{110}$ \\
$\texttt{1?1?0} \rightarrow \texttt{111}$ \\
\end{minipage}
\end{center}
